<!DOCTYPE html>
<meta charset="utf-8" />
<label class="myItems">Hello</label>
<label class="myItems">World!</label>

<script src="jqflower.js"></script>
<script>
try {


queryAll([document, '.myItems']).reduce(function (a, b) {
    a.push(b);
}, []);
// also consider https://github.com/nkallen/jquery-database
var result = JQFlower().
// XML Pipelining / XProc functions: http://www.ibm.com/developerworks/library/x-xproc/
	$declaration(
		{output:[]}
	).
	$( // Better to put wrapper outside, but can at least put in order here if desired
		document.body
	).
	$for(
		['$a', $at('count'), $in(document, '.myItems')],
		{$a: $in([document, '.myItems']), // Fix: also allow $in() to accept callback, e.g., auto-generated by Ajax-creator funtion
		at: '$count' // for numbering count as go along
		}, // allow retrieval from server, and also allow XPath (e.g. MDBX?)
// allow joining multiple nodes in association with first without need for count (and way to make up for difference with append)
		// also allow callback which is given 'this' as argument to continue the chain instead (since asynchronous);
		{$a: JSONP(url, function (flower) { // JSONP returns the function so $for can detect it should call with 'this'?
			flower.$let().$where().$return(function () {document.body.appendChild($a);});
		})}
	). // Fix: allow multiple 'for's (including non-nested joinable ones in the same $for())
	$at('$count').
	$at({'$item': arr}).
	$at({'$item': function (ct, node) {
		return arr[ct] ? arr[c] : 'something else';
	}}).
	$let([
		{$b:5},
		// call functions with the count and/or 'for'?
		{$c: function () { // Fix: make one useful for XML and one useful for JSON
			// Fix: also allow {$c: letter('$a', '@value')}
			// {$c: increment(data)}
			return string(this.$a);
		}}
	]).
	// allow this too?
	// $for('$a', $in('.myItems', document))
	/**/
	$where(function () { // Fix: add custom where and orderBy specific to XML and ones specific to JSON; demo calling function to return function,
	// e.g., $where('$a', '>', '$b')
		return number(this.$a) > 5;
	}).
	$orderBy(function (a, b) {
		// e.g., $orderBy('@value', 'asc')
		// If a zero or single argument defined function, just treat it as returning all filtered (with argument as the nodes)
		return a.attr('value') > b.attr('value'); // [?value]\\
	}).
	//*/
	// Fix: throw if any extra return function calls
	// Fix: decide whether recursion needs to be nested inside here, or can be as next chained call; should be chained since two subsequent "for"'s must be (unless using return); specify output as "input" so continues into other process
	$return(function (output) { // Demo as output XML DOM, XML String (concat with outside HTML string for use in $J()), or JSON Object, JSON array, and JSON string
		// XML.$for(...); // Fix: Test nested and demo a join! 
		// Demo modification of input nodes (XQUF)
		//$return(push('string($a) + $b;'));
		output.push(string(this.$a) + this.$b); // $count, etc.
	});
alert(result);
// Make XML.for and a JSON.for classes, which have different default where/orderBy (and include different built-in static classes)

var result = $for({$a: '.myItems'}, document).
                $let({$b: '$a.length'}). // also allow $let({$b:function () {return this.$a.length;}}).
                //or $let({$b:function () this.$a.length}). in JS 1.8
                    $return('alert(string($a) + $b);');
                     // also allow $return(function ($a) {return string(this.$a) + this.$b;}); // with the $a in the arguments being the latest or 2nd latest for (but not let?)?
                     // could also refer to global if set up global "var $a, $b;", etc.?

var result = $for({$a: '.myItems'}, document).
                // Fix: At least allow "for"'s to be accessible as $a ($b, etc.) arguments like this:
                $let(function ($a, $b) {return {$c:string($a)+string($b)};}).  // Do we need this? // Fix: (function($a,$b) {     })();
                    $return('alert(string($a) + $b);');


}
catch(e) {
alert(e);
}



</script>