<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>jqFlower Test</title>
<label class="myItems">Hello</label>
<label class="myItems">World!</label>
</head>
<body>

<script src="jqflower.js"></script>
<script>
/* globals queryAll, $for, $at, $in, JQFlower, string, number, JSONP, url */
try {
  queryAll([document, '.myItems']).reduce(function (a, b) {
    a.push(b);
  }, []);
  // also consider https://github.com/nkallen/jquery-database
  let result = new JQFlower()
    // XML Pipelining / XProc functions: http://www.ibm.com/developerworks/library/x-xproc/
    .$declaration(
      {output: []}
    )
    .$( // Better to put wrapper outside, but can at least put in order here if desired
      document.body
    )
    .$for(
      ['$a', $at('count'), $in(document, '.myItems')],
      {$a: $in([document, '.myItems']), // Fix: also allow $in() to accept callback, e.g., auto-generated by Ajax-creator funtion
        at: '$count' // for numbering count as go along
      }, // allow retrieval from server, and also allow XPath (e.g. MDBX?)
      // allow joining multiple nodes in association with first without need for count (and way to make up for difference with append)
      // also allow callback which is given 'this' as argument to continue the chain instead (since asynchronous);
      {$a: JSONP(url, function (flower) { // JSONP returns the function so $for can detect it should call with 'this'?
        flower.$let().$where().$return(function () { document.body.append($a); });
      })}
    ) // Fix: allow multiple 'for's (including non-nested joinable ones in the same $for())
    .$at('$count')
    .$at({$item: arr})
    .$at({'$item' (ct, node) {
      return arr[ct] ? arr[c] : 'something else';
    }}).$let([
      {$b: 5},
      // call functions with the count and/or 'for'?
      {$c () { // Fix: make one useful for XML and one useful for JSON
        // Fix: also allow {$c: letter('$a', '@value')}
        // {$c: increment(data)}
        return string(this.$a);
      }}
    ])
    // allow this too?
    // $for('$a', $in('.myItems', document))
    /**/
    .$where(function () { // Fix: add custom where and orderBy specific to XML and ones specific to JSON; demo calling function to return function,
    // e.g., $where('$a', '>', '$b')
      return number(this.$a) > 5;
    }).$orderBy(function (a, b) {
      // e.g., $orderBy('@value', 'asc')
      // If a zero or single argument defined function, just treat it as returning all filtered (with argument as the nodes)
      return a.attr('value') > b.attr('value'); // [?value]\\
    })
    // */
    // Fix: throw if any extra return function calls
    // Fix: decide whether recursion needs to be nested inside here, or can be as next chained call; should be chained since two subsequent "for"'s must be (unless using return); specify output as "input" so continues into other process
    .$return(function (output) { // Demo as output XML DOM, XML String (concat with outside HTML string for use in $J()), or JSON Object, JSON array, and JSON string
      // XML.$for(...); // Fix: Test nested and demo a join!
      // Demo modification of input nodes (XQUF)
      // $return(push('string($a) + $b;'));
      output.push(string(this.$a) + this.$b); // $count, etc.
    });

  // eslint-disable-next-line no-alert
  alert(result);
  // Make XML.for and a JSON.for classes, which have different default where/orderBy (and include different built-in static classes)

  result = $for({$a: '.myItems'}, document)
    .$let({$b: '$a.length'}) // also allow $let({$b:function () {return this.$a.length;}}).
    // or $let({$b:function () this.$a.length}). in JS 1.8
    .$return('alert(string($a) + $b);');
  // also allow $return(function ($a) {return string(this.$a) + this.$b;}); // with the $a in the arguments being the latest or 2nd latest for (but not let?)?
  // could also refer to global if set up global "var $a, $b;", etc.?

  result = $for({$a: '.myItems'}, document)
    // Fix: At least allow "for"'s to be accessible as $a ($b, etc.) arguments like this:
    .$let(function ($a, $b) { return {$c: string($a) + string($b)}; }) // Do we need this? // Fix: (function($a,$b) {   })();
    .$return('alert(string($a) + $b);');
} catch (e) {
  // eslint-disable-next-line no-alert
  alert(e);
}
</script>

</body>
</html>
